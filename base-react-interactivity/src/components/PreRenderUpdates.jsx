import React, { useState } from 'react'

// Демонстрация работы c очередью обновлений(очередью рендеринга)
export function UpdatedCounter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <p>{number}</p>
            <button
                onClick={() => {
                    setNumber((n) => n + 1);
                    setNumber((n) => n + 1);
                    setNumber((n) => n + 1);
                }}
            >
                +3
            </button>
        </>
    );
};
// Данная функция - (n) => n + 1 - называется апдейтером и вычисляет соедущее значение на основе предидущего в очереди -
// - говорим React-у - "не заменяй занчение состояния, а сделай с ним что-нибудь".

// Этапы работы функции (n) => n + 1 - 
// - (также, передаёт (в n) значение по умолчанию из useState(0)(в данном случае 0) для функции-аргумента, находящейся в setNumber).
// 1. React ставит эту функцию в очередь на обработку после выполнения всего остального кода в обработчике событий.
// 2. Во время следующего рендеринга React просматривает очередь и выдает окончательное обновленное состояние.

// !!! React ждет, пока будет выполнен весь код внутри обработчика событий, прежде чем обрабатывать наши обновления состояния !!! =>
// => повторный рендеринг происходит только после всех вызовов setNumber, в данном случае.

// пользовательский интерфейс не будет обновляться до тех пор, пока не завершится ваш обработчик событий и любой код в нем.
// Данное поведение называется БАТЧИНГ. Онозаставляет работать React-приложение намного быстрее. 

// Улучшенная версия счётчика +5 - теперь +6
export function UpdatedFiveCounter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <p>{number}</p>
            <button
                onClick={() => {
                    setNumber(number + 5);
                    setNumber((n) => n + 1);
                }}
            >
                +6
            </button>
        </>
    );
};
// setNumber(number + 5); - заменяет 0 на 5 (так как useState(0)).
// setNumber((n) => n + 1); - React добавляет эту функцию в свою очередь => после, прибавляет к 5-ти 1-цу. 
// По итогу вычислений вернет 6 как конечный результат.

// Изменённая версия счётчика +6
export function UpdatedSixCounter() {
    const [number, setNumber] = useState(0);

    return (
        <>
            <p>{number}</p>
            <button
                onClick={() => {
                    setNumber(number + 5);
                    setNumber((n) => n + 1);
                    setNumber(42);
                }}
            >
                ???
            </button>
        </>
    );
};
// setNumber(42) = seNumber(number + 42) - эта строка, выполняемая последней, заменяет 6 на 42 -
// - говорит - "игнорируй результат поставленный в очередь (6), и замени его на (42)".

export default function PreRenderUpdates() {
    return (
        <>
            <div className="main-container">
            <h2>Усовершенствованная версия работы счетчика +3 из прошлого раздела</h2>
            <UpdatedCounter />
            <hr></hr>
            <h2>Усовершенствованная версия работы счетчика +5 из прошлого раздела - теперь +6</h2>
            <UpdatedFiveCounter />
            <hr></hr>
            <h2>Усовершенствованная версия работы счетчика +6 из примера выше</h2>
            <UpdatedSixCounter />
            <hr></hr>
            </div>
        </>
    );
};